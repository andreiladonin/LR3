<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR 3D Object with Gesture Control</title>
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    #videoCanvas { position: absolute; top: 0; left: 0; z-index: 100; opacity: 0.5; }
    video { display: none; }
  </style>
</head>
<body>
  <!-- Видео для захвата камеры -->
  <video id="myvideo" autoplay playsinline></video>
  <!-- Канвас для отображения отслеживания рук -->
  <canvas id="videoCanvas"></canvas>

  <!-- A-Frame сцена -->
  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true;"
    webxr="requiredFeatures: local-floor;"
  >
    <!-- Фон для 3D-режима -->
    <a-sky color="#87CEEB"></a-sky>

    <!-- Первый куб (красный) -->
    <a-box
      id="targetObject1"
      position="-0.3 0.5 -0.5"  <!-- Ближе к камере -->
      rotation="0 0 0"
      scale="0.5 0.5 0.5"
      color="red"
      material="opacity: 0.8;"
    ></a-box>

    <!-- Второй куб (синий) -->
    <a-box
      id="targetObject2"
      position="0.3 0.5 -0.5"  <!-- Ближе к камере -->
      rotation="0 0 0"
      scale="0.5 0.5 0.5"
      color="blue"
      material="opacity: 0.8;"
    ></a-box>

    <!-- Камера -->
    <a-entity camera look-controls position="0 1.6 0"></a-entity>
  </a-scene>

  <script>
    // Проверка поддержки WebXR
    if (!navigator.xr) {
      console.error("WebXR not supported by this browser/device.");
      alert("WebXR not supported. Falling back to 3D mode.");
    } else {
      navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
        if (!supported) {
          console.error("Immersive AR not supported by this browser/device.");
          alert("Immersive AR not supported. Falling back to 3D mode.");
        }
      }).catch((err) => {
        console.error("WebXR support check failed:", err);
        alert("WebXR check failed: " + err.message);
      });
    }

    // Инициализация MediaPipe Hands
    const video = document.getElementById("myvideo");
    const canvas = document.getElementById("videoCanvas");
    const ctx = canvas.getContext("2d");

    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    let isHandClosed = false;
    let lastHandX = null;

    hands.onResults((results) => {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      const targetObject1 = document.getElementById("targetObject1");
      const targetObject2 = document.getElementById("targetObject2");

      if (results.multiHandLandmarks) {
        for (const landmarks of results.multiHandLandmarks) {
          for (const landmark of landmarks) {
            const x = landmark.x * canvas.width;
            const y = landmark.y * canvas.height;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = "green";
            ctx.fill();
          }

          const thumbTip = landmarks[4];
          const indexTip = landmarks[8];
          const distance = Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2)
          );
          isHandClosed = distance < 0.15;

          const handX = landmarks[0].x * canvas.width;

          let scale = parseFloat(targetObject1.getAttribute("scale").x);
          if (isHandClosed) {
            scale = Math.max(0.2, scale - 0.01);
          } else {
            scale = Math.min(2.0, scale + 0.01);
          }
          targetObject1.setAttribute("scale", `${scale} ${scale} ${scale}`);
          targetObject2.setAttribute("scale", `${scale} ${scale} ${scale}`);

          if (lastHandX !== null) {
            const deltaX = handX - lastHandX;
            let rotation1 = targetObject1.getAttribute("rotation");
            let rotation2 = targetObject2.getAttribute("rotation");
            rotation1.y += deltaX * 100;
            rotation2.y += deltaX * 100;
            targetObject1.setAttribute("rotation", rotation1);
            targetObject2.setAttribute("rotation", rotation2);
          }
          lastHandX = handX;
        }
      } else {
        lastHandX = null;
      }
      ctx.restore();
    });

    // Проверка доступных камер и выбор задней камеры
    async function startCamera() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        console.log("Available cameras:", videoDevices);

        let videoConstraints = { width: window.innerWidth, height: window.innerHeight };
        
        const rearCamera = videoDevices.find(device => 
          device.label.toLowerCase().includes('back') || 
          device.label.toLowerCase().includes('rear') || 
          device.label.toLowerCase().includes('environment')
        );

        if (rearCamera) {
          console.log("Using rear camera:", rearCamera.label);
          videoConstraints.deviceId = { exact: rearCamera.deviceId };
        } else {
          console.warn("Rear camera not found, falling back to default camera.");
          alert("Rear camera not found. Using default camera. Switch to rear camera if possible.");
          videoConstraints.facingMode = "environment";
        }

        const stream = await navigator.mediaDevices.getUserMedia({
          video: videoConstraints
        });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          processFrame();
        };
      } catch (err) {
        console.error("Camera start error:", err);
        alert("Failed to start camera: " + err.message);
      }
    }

    async function processFrame() {
      await hands.send({ image: video });
      requestAnimationFrame(processFrame);
    }

    startCamera();

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const scene = document.querySelector("a-scene");
    scene.addEventListener("loaded", () => {
      console.log("A-Frame scene loaded");
    });
    scene.addEventListener("enter-vr", () => {
      console.log("Entered AR mode");
      alert("AR mode activated! Look for the red and blue cubes on a flat surface.");
    });
    scene.addEventListener("exit-vr", () => {
      console.log("Exited AR mode");
    });
    scene.addEventListener("arError", (e) => {
      console.error("AR error:", e.detail);
      alert("AR failed: " + e.detail);
    });

    // Отладка рендеринга
    scene.addEventListener("renderstart", () => {
      console.log("Rendering started. Cubes should be visible in 3D mode.");
    });
  </script>
</body>
</html>