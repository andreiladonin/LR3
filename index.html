<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AR 3D Object with Gesture Control</title>
  <!-- A-Frame -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.js" crossorigin="anonymous"></script>
  <style>
    body { margin: 0; overflow: hidden; }
    #videoCanvas { position: absolute; top: 0; left: 0; z-index: 100; opacity: 0.5; }
    video { display: none; }
    a-scene { z-index: 0; }
  </style>
</head>
<body>
  <video id="myvideo" autoplay playsinline></video>
  <canvas id="videoCanvas"></canvas>

  <a-scene
    embedded
    vr-mode-ui="enabled: false"
    renderer="logarithmicDepthBuffer: true;"
    webxr="requiredFeatures: local-floor;"
  >
    <a-sky color="#87CEEB"></a-sky>
    <a-box
      id="targetObject1"
      position="-0.3 0 -0.3"
      rotation="0 0 0"
      scale="0.5 0.5 0.5"
      color="red"
      material="opacity: 0.8;"
    ></a-box>
    <a-box
      id="targetObject2"
      position="0.3 0 -0.3"
      rotation="0 0 0"
      scale="0.5 0.5 0.5"
      color="blue"
      material="opacity: 0.8;"
    ></a-box>
    <a-entity camera look-controls position="0 0 0"></a-entity>
  </a-scene>

  <script>
    if (!navigator.xr) {
      console.error("WebXR not supported by this browser/device.");
      alert("WebXR not supported. Falling back to 3D mode.");
    } else {
      navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
        if (!supported) {
          console.error("Immersive AR not supported by this browser/device.");
          alert("Immersive AR not supported. Falling back to 3D mode.");
        }
      }).catch((err) => {
        console.error("WebXR support check failed:", err);
        alert("WebXR check failed: " + err.message);
      });
    }

    const video = document.getElementById("myvideo");
    const canvas = document.getElementById("videoCanvas");
    const ctx = canvas.getContext("2d");

    const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}` });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    let isHandClosed = false;
    let lastHandX = null;
    let targetRotationY = 0; // Целевой угол поворота
    let currentRotationY = 0; // Текущий угол поворота (для сглаживания)
    const smoothingFactor = 0.1; // Коэффициент сглаживания (0-1)
    const rotationSpeed = 50; // Уменьшенный коэффициент вращения

    // Массив для усреднения handX (фильтрация шума)
    const handXHistory = [];
    const historyLength = 5; // Количество кадров для усреднения

    hands.onResults((results) => {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

      const targetObject1 = document.getElementById("targetObject1");
      const targetObject2 = document.getElementById("targetObject2");

      if (results.multiHandLandmarks) {
        for (const landmarks of results.multiHandLandmarks) {
          for (const landmark of landmarks) {
            const x = landmark.x * canvas.width;
            const y = landmark.y * canvas.height;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2 * Math.PI);
            ctx.fillStyle = "green";
            ctx.fill();
          }

          const thumbTip = landmarks[4];
          const indexTip = landmarks[8];
          const distance = Math.sqrt(
            Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2)
          );
          isHandClosed = distance < 0.15;

          // Усреднение handX для фильтрации шума
          let handX = landmarks[0].x * canvas.width;
          handXHistory.push(handX);
          if (handXHistory.length > historyLength) handXHistory.shift();
          const avgHandX = handXHistory.reduce((sum, val) => sum + val, 0) / handXHistory.length;

          // Вычисление смещения и целевого угла поворота
          if (lastHandX !== null) {
            const deltaX = avgHandX - lastHandX;
            targetRotationY += deltaX * rotationSpeed;
          }
          lastHandX = avgHandX;

          // Сглаживание поворота (линейная интерполяция)
          currentRotationY += (targetRotationY - currentRotationY) * smoothingFactor;

          // Применение сглаженного поворота
          targetObject1.setAttribute("rotation", `0 ${currentRotationY} 0`);
          targetObject2.setAttribute("rotation", `0 ${currentRotationY} 0`);

          let scale = parseFloat(targetObject1.getAttribute("scale").x);
          if (isHandClosed) {
            scale = Math.max(0.2, scale - 0.01);
          } else {
            scale = Math.min(2.0, scale + 0.01);
          }
          targetObject1.setAttribute("scale", `${scale} ${scale} ${scale}`);
          targetObject2.setAttribute("scale", `${scale} ${scale} ${scale}`);
        }
      } else {
        lastHandX = null;
      }
      ctx.restore();
    });

    async function startCamera() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = devices.filter(device => device.kind === 'videoinput');
        console.log("Available cameras:", videoDevices);

        let videoConstraints = { width: window.innerWidth, height: window.innerHeight };
        
        const rearCamera = videoDevices.find(device => 
          device.label.toLowerCase().includes('back') || 
          device.label.toLowerCase().includes('rear') || 
          device.label.toLowerCase().includes('environment')
        );

        if (rearCamera) {
          console.log("Using rear camera:", rearCamera.label);
          videoConstraints.deviceId = { exact: rearCamera.deviceId };
        } else {
          console.warn("Rear camera not found, falling back to default camera.");
          alert("Rear camera not found. Using default camera. Switch to rear camera if possible.");
          videoConstraints.facingMode = "environment";
        }

        const stream = await navigator.mediaDevices.getUserMedia({
          video: videoConstraints
        });
        video.srcObject = stream;
        video.onloadedmetadata = () => {
          video.play();
          processFrame();
        };
      } catch (err) {
        console.error("Camera start error:", err);
        alert("Failed to start camera: " + err.message);
      }
    }

    async function processFrame() {
      await hands.send({ image: video });
      requestAnimationFrame(processFrame);
    }

    startCamera();

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const scene = document.querySelector("a-scene");
    scene.addEventListener("loaded", () => {
      console.log("A-Frame scene loaded");
    });
    scene.addEventListener("enter-vr", () => {
      console.log("Entered AR mode");
      alert("AR mode activated! Look for the red and blue cubes on a flat surface.");
    });
    scene.addEventListener("exit-vr", () => {
      console.log("Exited AR mode");
    });
    scene.addEventListener("arError", (e) => {
      console.error("AR error:", e.detail);
      alert("AR failed: " + e.detail);
    });

    scene.addEventListener("renderstart", () => {
      console.log("Rendering started. Cubes should be visible in 3D mode.");
    });

    setTimeout(() => {
      if (!scene.is('rendering')) {
        console.warn("Rendering not started. Forcing scene render.");
        scene.setAttribute('renderer', 'logarithmicDepthBuffer: true');
      }
    }, 2000);

    // Отладка FPS
    let lastTime = performance.now();
    let frameCount = 0;
    let fps = 0;
    setInterval(() => {
      const now = performance.now();
      const delta = (now - lastTime) / 1000;
      fps = frameCount / delta;
      console.log(`FPS: ${fps.toFixed(1)}`);
      frameCount = 0;
      lastTime = now;
    }, 1000);

    function tick() {
      frameCount++;
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>